<topic>
strategy pattern（策略模式）
</topic>
</br></br>
<currentSection>
<header>
如何实现策略模式？（必要的代码结构）
</header>
</br></br>
<script1>
大家好，接下来由我为大家介绍“如何实现策略模式”，，通常情况下，策略模式需要包含一下核心的角色：
上下文（Context）、
抽象策略（Strategy）、
具体策略（Concrete Strategy）。
<optionalTalk>
 1. 上下文（Context）：指的是用来操作策略的上下文环境，它可以屏蔽高层模块对具体策略的直接访问。Context里要维护一个对策略对象的引用，负责将客户端请求委派给具体的策略对象执行。
2. 抽象策略（Strategy）：定义了一个公共接口，各种不同的策略以各自的算法实现这个接口，上下文只需要调用这个接口，就可以执行不同的策略。
3. 具体策略（Concrete Strategy）：实现了抽象策略定义的接口，提供具体的算法实现。
</optionalTalk>
</script1>
</br></br>
<script2>
- **上下文 (Context)** 维护一个指向具体策略的引用，并仅通过抽象策略接口与该对象通信;
- **抽象策略 (Strategy)** 定义一个执行策略的公共接口。
- **具体策略 (Concrete Strategies)** ，所有具体策略都会实现这个接口。
- 每当上下文需要运行算法时，它只会调用链接的策略对象上的执行方法。而不需要知道策略对象的具体类型。
- 在**客户端 (Client)**应用中运行时， 我们需要new一个具体的策略对象，并将其set到context中。然后调用contex的doSomethin方法。通常context需要暴露一个（setter）方法，以允许客户端在运行时切换关联的策略。
</script2>
</br></br>
<script3>
接下来我会介绍一个“导航应用”的示例。
我们出行的交通方式通常有 步行、自行车汽车、bus等。

没有采用策略模式的时候，每种交通方式都会有一个策略，我们的导航策略耦合度会很高，后续的修改或者增加新的导航策略，都会增加很多工作量。

我们可以将每个路线规划算法都抽取出来，形成具体的策略类，这些策略类都约定实现一个公共的 `buildRoute` 方法，该方法返回一个路线规划结果。
公共的 `buildRoute` 接口方法放到抽象策略类中。
</script3>
</currentSection>


